<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Capture first match</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{vignette 1: capture first match}
-->

<h1>Capture first match</h1>

<h2>Capture first match in each character vector element</h2>

<p>Consider the following vector which contains genome position strings,</p>

<pre><code class="r">pos.vec &lt;- c(
  &quot;chr10:213,054,000-213,055,000&quot;,
  &quot;chrM:111,000&quot;,
  &quot;chr1:110-111 chr2:220-222&quot;) # two possible matches.
</code></pre>

<p>To capture the first genome position in each string, we use the following syntax.
The first argument is the subject character vector, 
and the other arguments are pasted together 
to make a capturing regular expression.
Each named argument generates a capture group; 
the R argument name is used for the column name of the result.</p>

<pre><code class="r">(chr.dt &lt;- nc::capture_first_vec(
  pos.vec, 
  chrom=&quot;chr.*?&quot;,
  &quot;:&quot;,
  chromStart=&quot;[0-9,]+&quot;))
#&gt;    chrom  chromStart
#&gt; 1: chr10 213,054,000
#&gt; 2:  chrM     111,000
#&gt; 3:  chr1         110
str(chr.dt)
#&gt; Classes &#39;data.table&#39; and &#39;data.frame&#39;:   3 obs. of  2 variables:
#&gt;  $ chrom     : chr  &quot;chr10&quot; &quot;chrM&quot; &quot;chr1&quot;
#&gt;  $ chromStart: chr  &quot;213,054,000&quot; &quot;111,000&quot; &quot;110&quot;
#&gt;  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;
</code></pre>

<p>We can add type conversion functions on the same line as each named argument:</p>

<pre><code class="r">keep.digits &lt;- function(x)as.integer(gsub(&quot;[^0-9]&quot;, &quot;&quot;, x))
(int.dt &lt;- nc::capture_first_vec(
  pos.vec, 
  chrom=&quot;chr.*?&quot;,
  &quot;:&quot;,
  chromStart=&quot;[0-9,]+&quot;, keep.digits))
#&gt;    chrom chromStart
#&gt; 1: chr10  213054000
#&gt; 2:  chrM     111000
#&gt; 3:  chr1        110
str(int.dt)
#&gt; Classes &#39;data.table&#39; and &#39;data.frame&#39;:   3 obs. of  2 variables:
#&gt;  $ chrom     : chr  &quot;chr10&quot; &quot;chrM&quot; &quot;chr1&quot;
#&gt;  $ chromStart: int  213054000 111000 110
#&gt;  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;
</code></pre>

<p>Below we use list variables to create patterns which are re-usable,
and we use an un-named list to generate a non-capturing optional group:</p>

<pre><code class="r">pos.pattern &lt;- list(&quot;[0-9,]+&quot;, keep.digits)
range.pattern &lt;- list(
  chrom=&quot;chr.*?&quot;,
  &quot;:&quot;,
  chromStart=pos.pattern,
  list(
    &quot;-&quot;,
    chromEnd=pos.pattern
  ), &quot;?&quot;)
nc::capture_first_vec(pos.vec, range.pattern)
#&gt;    chrom chromStart  chromEnd
#&gt; 1: chr10  213054000 213055000
#&gt; 2:  chrM     111000        NA
#&gt; 3:  chr1        110       111
</code></pre>

<p>In summary, <code>nc::capture_first_vec</code> takes a variable number of arguments:</p>

<ul>
<li>The first argument is the subject character vector.</li>
<li>The other arguments specify the pattern, via character strings,
functions, and/or lists.</li>
<li>If a pattern (character/list) is named, a capture group is generated in the regex.</li>
<li>Each function is used to convert the text extracted by the previous
named pattern argument.</li>
<li>Lists may be used to avoid repetition in the definition of the pattern and type conversion functions.</li>
<li>Each list generates a group in the regex (named list =&gt; named capture group, un-named list =&gt; non-capturing group).</li>
<li>All patterns are pasted together in the order that they appear in
the argument list.</li>
</ul>

<h2>View generated regex</h2>

<p>To see the generated regular expression pattern string, call
<code>nc::var_args_list</code> with the variable number of arguments that
specify the pattern:</p>

<pre><code class="r">nc::var_args_list(range.pattern)
#&gt; $fun.list
#&gt; $fun.list$chrom
#&gt; function (x) 
#&gt; x
#&gt; &lt;bytecode: 0x00000000133256d8&gt;
#&gt; &lt;environment: namespace:base&gt;
#&gt; 
#&gt; $fun.list$chromStart
#&gt; function(x)as.integer(gsub(&quot;[^0-9]&quot;, &quot;&quot;, x))
#&gt; &lt;bytecode: 0x00000000150d78a8&gt;
#&gt; 
#&gt; $fun.list$chromEnd
#&gt; function(x)as.integer(gsub(&quot;[^0-9]&quot;, &quot;&quot;, x))
#&gt; &lt;bytecode: 0x00000000150d78a8&gt;
#&gt; 
#&gt; 
#&gt; $pattern
#&gt; [1] &quot;(?:(chr.*?):([0-9,]+)(?:-([0-9,]+))?)&quot;
</code></pre>

<p>The generated regex is the <code>pattern</code> element of the resulting list
above. The other element <code>fun.list</code> indicates the names and type
conversion functions to use with the capture groups.</p>

<h2>Error/NA if any subjects do not match</h2>

<p>The default is to stop with an error if any subject does not match:</p>

<pre><code class="r">bad.vec &lt;- c(bad=&quot;does not match&quot;, pos.vec)
nc::capture_first_vec(bad.vec, range.pattern)
#&gt; Error in stop_for_na(make.na): subject 1 did not match regex below; to output missing rows use nomatch.error=FALSE
#&gt; (?:(chr.*?):([0-9,]+)(?:-([0-9,]+))?)
</code></pre>

<p>Sometimes you want to instead report a row of NA when a subject does
not match. In that case, use <code>nomatch.error=FALSE</code>:</p>

<pre><code class="r">nc::capture_first_vec(bad.vec, range.pattern, nomatch.error=FALSE)
#&gt;    chrom chromStart  chromEnd
#&gt; 1:  &lt;NA&gt;         NA        NA
#&gt; 2: chr10  213054000 213055000
#&gt; 3:  chrM     111000        NA
#&gt; 4:  chr1        110       111
</code></pre>

<h2>Other regex engines</h2>

<p>By default nc uses the PCRE regex engine. Other choices include ICU
and RE2. Each engine has different features, which are discussed in
<a href="https://github.com/tdhock/namedCapture-article">my R journal paper</a>.</p>

<p>The engine is configurable via the <code>engine</code> argument or the
<code>nc.engine</code> option:</p>

<pre><code class="r">u.subject &lt;- &quot;a\U0001F60E#&quot;
u.pattern &lt;- list(emoji=&quot;\\p{EMOJI_Presentation}&quot;)
old.opt &lt;- options(nc.engine=&quot;ICU&quot;)
nc::capture_first_vec(u.subject, u.pattern)
#&gt;           emoji
#&gt; 1: &lt;U+0001F60E&gt;
nc::capture_first_vec(u.subject, u.pattern, engine=&quot;PCRE&quot;) 
#&gt; Warning in regexpr(L$pattern, subject.vec, perl = TRUE): PCRE pattern compilation error
#&gt;  &#39;unknown property name after \P or \p&#39;
#&gt;  at &#39;}))&#39;
#&gt; Error in value[[3L]](cond): (?:(\p{EMOJI_Presentation}))
#&gt; when matching pattern above with PCRE engine, an error occured: invalid regular expression &#39;(?:(\p{EMOJI_Presentation}))&#39;
nc::capture_first_vec(u.subject, u.pattern, engine=&quot;RE2&quot;)
#&gt; Error in value[[3L]](cond): (?:(\p{EMOJI_Presentation}))
#&gt; when matching pattern above with RE2 engine, an error occured: bad character class range: \p{EMOJI_Presentation}
options(old.opt)
</code></pre>

<h2>Capture first match from one or more data.frame character columns</h2>

<p>We also provide <code>nc::capture_first_df</code> which extracts text
from several columns of a data.frame, using a different 
regular expression for each column.</p>

<ul>
<li>It requires a data.frame (or data.table) as the first argument.</li>
<li>It takes a variable number of other arguments, all of which must be
named. For each other argument we call <code>nc::capture_first_vec</code> on one
column of the input data.frame.</li>
<li>Each argument name specifies a column of the data.frame which will
be used as the subject in <code>nc::capture_first_vec</code>.</li>
<li>Each argument value specifies a pattern to be used with
<code>nc::capture_first_vec</code>, in list/character/function format as
explained in the previous section.</li>
<li>The return value is a data.table with the same number of rows as the
input, but with an additional column for each named capture
group. New columns are named using the R argument names, so make
sure they are unique.</li>
<li>This function inputs data.frame and outputs data.table so can be used in a
<a href="https://r4ds.had.co.nz/pipes.html">pipe</a>.</li>
</ul>

<p>This function can greatly simplify the code required to create numeric
data columns from character data columns. For example consider the
following data which was output from the <a href="https://slurm.schedmd.com/sacct.html">sacct</a> program.</p>

<pre><code class="r">(sacct.df &lt;- data.frame(
  Elapsed = c(
    &quot;07:04:42&quot;, &quot;07:04:42&quot;, &quot;07:04:49&quot;,
    &quot;00:00:00&quot;, &quot;00:00:00&quot;),
  JobID=c(
    &quot;13937810_25&quot;,
    &quot;13937810_25.batch&quot;,
    &quot;13937810_25.extern&quot;,
    &quot;14022192_[1-3]&quot;,
    &quot;14022204_[4]&quot;),
  stringsAsFactors=FALSE))
#&gt;    Elapsed              JobID
#&gt; 1 07:04:42        13937810_25
#&gt; 2 07:04:42  13937810_25.batch
#&gt; 3 07:04:49 13937810_25.extern
#&gt; 4 00:00:00     14022192_[1-3]
#&gt; 5 00:00:00       14022204_[4]
</code></pre>

<p>Say we want to filter by the total Elapsed time (which is reported as
hours:minutes:seconds), and base job id (which is the number before
the underscore in the JobID column). We could start by converting
those character columns to integers via:</p>

<pre><code class="r">int.pattern &lt;- list(&quot;[0-9]+&quot;, as.integer)
range.pattern &lt;- list(
  &quot;\\[&quot;,
  task1=int.pattern,
  list(
    &quot;-&quot;,#begin optional end of range.
    taskN=int.pattern
  ), &quot;?&quot;, #end is optional.
  &quot;\\]&quot;)
nc::capture_first_df(sacct.df, JobID=range.pattern, nomatch.error=FALSE)
#&gt;     Elapsed              JobID task1 taskN
#&gt; 1: 07:04:42        13937810_25    NA    NA
#&gt; 2: 07:04:42  13937810_25.batch    NA    NA
#&gt; 3: 07:04:49 13937810_25.extern    NA    NA
#&gt; 4: 00:00:00     14022192_[1-3]     1     3
#&gt; 5: 00:00:00       14022204_[4]     4    NA
</code></pre>

<p>The result shown above is another data frame with an additional column
for each capture group. Next, we define another pattern that
matches either one task ID or the previously defined range pattern:</p>

<pre><code class="r">task.pattern &lt;- list(
  &quot;_&quot;,
  list(
    task=int.pattern,
    &quot;|&quot;,#either one task(above) or range(below)
    range.pattern))
nc::capture_first_df(sacct.df, JobID=task.pattern)
#&gt;     Elapsed              JobID task task1 taskN
#&gt; 1: 07:04:42        13937810_25   25    NA    NA
#&gt; 2: 07:04:42  13937810_25.batch   25    NA    NA
#&gt; 3: 07:04:49 13937810_25.extern   25    NA    NA
#&gt; 4: 00:00:00     14022192_[1-3]   NA     1     3
#&gt; 5: 00:00:00       14022204_[4]   NA     4    NA
</code></pre>

<p>Below we match the complete JobID column:</p>

<pre><code class="r">job.pattern &lt;- list(
  job=int.pattern,
  task.pattern,
  list(
    &quot;[.]&quot;,
    type=&quot;.*&quot;
  ), &quot;?&quot;)
nc::capture_first_df(sacct.df, JobID=job.pattern)
#&gt;     Elapsed              JobID      job task task1 taskN   type
#&gt; 1: 07:04:42        13937810_25 13937810   25    NA    NA       
#&gt; 2: 07:04:42  13937810_25.batch 13937810   25    NA    NA  batch
#&gt; 3: 07:04:49 13937810_25.extern 13937810   25    NA    NA extern
#&gt; 4: 00:00:00     14022192_[1-3] 14022192   NA     1     3       
#&gt; 5: 00:00:00       14022204_[4] 14022204   NA     4    NA
</code></pre>

<p>Below we match the Elapsed column with a different regex:</p>

<pre><code class="r">elapsed.pattern &lt;- list(
  hours=int.pattern,
  &quot;:&quot;,
  minutes=int.pattern,
  &quot;:&quot;,
  seconds=int.pattern)
nc::capture_first_df(sacct.df, JobID=job.pattern, Elapsed=elapsed.pattern)
#&gt;     Elapsed              JobID      job task task1 taskN   type hours minutes
#&gt; 1: 07:04:42        13937810_25 13937810   25    NA    NA            7       4
#&gt; 2: 07:04:42  13937810_25.batch 13937810   25    NA    NA  batch     7       4
#&gt; 3: 07:04:49 13937810_25.extern 13937810   25    NA    NA extern     7       4
#&gt; 4: 00:00:00     14022192_[1-3] 14022192   NA     1     3            0       0
#&gt; 5: 00:00:00       14022204_[4] 14022204   NA     4    NA            0       0
#&gt;    seconds
#&gt; 1:      42
#&gt; 2:      42
#&gt; 3:      49
#&gt; 4:       0
#&gt; 5:       0
</code></pre>

<p>Overall the result is another data table with an additional column for
each capture group. </p>

<h2>Complex example: fsa file names</h2>

<p>In this section we explain how to use various features to parse the
fsa file names in
<a href="https://lftdi.camden.rutgers.edu/provedit/files/">PROVEDIt</a>. Here are
a few representative examples:</p>

<pre><code class="r">fsa.vec &lt;- c(#control samples:
  &quot;A01-Ladder-PP16-001.10sec.fsa&quot;,
  &quot;D07_Ladder-IP_004.5sec.fsa&quot;,
  &quot;A12_RB121514ADG_001.10sec.fsa&quot;, 
  &quot;A10_RB102191515LEA-IP_001.10sec.fsa&quot;,
  ##single-source samples:
  &quot;A02-RD12-0002-35-0.5PP16-001.10sec.fsa&quot;, 
  &quot;G01_RD14-0003-35d3S30-0.01563P-Q10.0_003.10sec.fsa&quot;,
  &quot;A06_RD14-0003-24d3a-0.0625IP-Q0.8_001.10sec.fsa&quot;, 
  &quot;A08-RD12-0002-01d-0.125PP16-001.10sec.fsa&quot;,
  &quot;A10-RD12-0002-04d1-0.0625PP16-001.10sec.fsa&quot;, 
  &quot;C02_RD14-0003-15d2b-0.25IP-Q0.5_003.5sec.fsa&quot;,
  ##mixture samples:
  &quot;A02-RD12-0002-1_2-1;9-0.125PP16-001.10sec.fsa&quot;, 
  &quot;H07_RD14-0003-35_36_37_38_39-1;4;4;4;1-M2I35-0.75IP-QLAND_004.5sec.fsa&quot;)
</code></pre>

<p>The goal is to build a regex that can convert this character vector to
a data table with different columns for the different variables. The
structure of the file names is explained in <a href="https://lftdi.camden.rutgers.edu/wp-content/uploads/2019/12/PROVEDIt-Database-Naming-Convention-Laboratory-Methodsv1.pdf">the supplementary
materials
PDF</a>. We
will build a complex regex in terms of simpler sub-patterns. First
let&#39;s just match the start of each file name, which has the row/column
of the 96-well plate in which the sample was tested:</p>

<pre><code class="r">well.pattern &lt;- list(
  &quot;^&quot;,
  well.letter=&quot;[A-H]&quot;,
  well.number=&quot;[0-9]+&quot;, as.integer)
nc::capture_first_vec(fsa.vec, well.pattern)
#&gt;     well.letter well.number
#&gt;  1:           A           1
#&gt;  2:           D           7
#&gt;  3:           A          12
#&gt;  4:           A          10
#&gt;  5:           A           2
#&gt;  6:           G           1
#&gt;  7:           A           6
#&gt;  8:           A           8
#&gt;  9:           A          10
#&gt; 10:           C           2
#&gt; 11:           A           2
#&gt; 12:           H           7
</code></pre>

<p>Now, let&#39;s match the end of each file name:</p>

<pre><code class="r">end.pattern &lt;- list(
  &quot;[-_]&quot;,
  capillary=&quot;[0-9]+&quot;, as.integer,
  &quot;[.]&quot;,
  seconds=&quot;[0-9]+&quot;, as.integer,
  &quot;sec[.]fsa$&quot;)
nc::capture_first_vec(fsa.vec, end.pattern)
#&gt;     capillary seconds
#&gt;  1:         1      10
#&gt;  2:         4       5
#&gt;  3:         1      10
#&gt;  4:         1      10
#&gt;  5:         1      10
#&gt;  6:         3      10
#&gt;  7:         1      10
#&gt;  8:         1      10
#&gt;  9:         1      10
#&gt; 10:         3       5
#&gt; 11:         1      10
#&gt; 12:         4       5
</code></pre>

<p>Now, let&#39;s take a look at what&#39;s in between:</p>

<pre><code class="r">between.dt &lt;- nc::capture_first_vec(
  fsa.vec, well.pattern, between=&quot;.*?&quot;, end.pattern)
between.dt$between
#&gt;  [1] &quot;-Ladder-PP16&quot;                                          
#&gt;  [2] &quot;_Ladder-IP&quot;                                            
#&gt;  [3] &quot;_RB121514ADG&quot;                                          
#&gt;  [4] &quot;_RB102191515LEA-IP&quot;                                    
#&gt;  [5] &quot;-RD12-0002-35-0.5PP16&quot;                                 
#&gt;  [6] &quot;_RD14-0003-35d3S30-0.01563P-Q10.0&quot;                     
#&gt;  [7] &quot;_RD14-0003-24d3a-0.0625IP-Q0.8&quot;                        
#&gt;  [8] &quot;-RD12-0002-01d-0.125PP16&quot;                              
#&gt;  [9] &quot;-RD12-0002-04d1-0.0625PP16&quot;                            
#&gt; [10] &quot;_RD14-0003-15d2b-0.25IP-Q0.5&quot;                          
#&gt; [11] &quot;-RD12-0002-1_2-1;9-0.125PP16&quot;                          
#&gt; [12] &quot;_RD14-0003-35_36_37_38_39-1;4;4;4;1-M2I35-0.75IP-QLAND&quot;
</code></pre>

<p>Notice that PP16/P/IP are the kit types. There may optionally be a DNA
template mass before, and optionally a Q score after. Let&#39;s match those:</p>

<pre><code class="r">mass.pattern &lt;- list(
  template.nanograms=&quot;[0-9.]*&quot;, as.numeric)
kit.pattern &lt;- nc::quantifier(
  kit=nc::alternatives(&quot;PP16&quot;, &quot;IP&quot;, &quot;P&quot;),
  &quot;?&quot;)
q.pattern &lt;- nc::quantifier(
  &quot;-Q&quot;,
  Q.chr=nc::alternatives(&quot;LAND&quot;, &quot;[0-9.]+&quot;),
  &quot;?&quot;)
old.opt &lt;- options(width=100)
(before.dt &lt;- nc::capture_first_vec(
  between.dt$between,
  &quot;^&quot;,
  before=&quot;.*?&quot;,
  mass.pattern, kit.pattern, q.pattern, &quot;$&quot;))
#&gt;                                         before template.nanograms  kit Q.chr
#&gt;  1:                                   -Ladder-                 NA PP16      
#&gt;  2:                                   _Ladder-                 NA   IP      
#&gt;  3:                               _RB121514ADG                 NA           
#&gt;  4:                           _RB102191515LEA-                 NA   IP      
#&gt;  5:                             -RD12-0002-35-            0.50000 PP16      
#&gt;  6:                        _RD14-0003-35d3S30-            0.01563    P  10.0
#&gt;  7:                          _RD14-0003-24d3a-            0.06250   IP   0.8
#&gt;  8:                            -RD12-0002-01d-            0.12500 PP16      
#&gt;  9:                           -RD12-0002-04d1-            0.06250 PP16      
#&gt; 10:                          _RD14-0003-15d2b-            0.25000   IP   0.5
#&gt; 11:                        -RD12-0002-1_2-1;9-            0.12500 PP16      
#&gt; 12: _RD14-0003-35_36_37_38_39-1;4;4;4;1-M2I35-            0.75000   IP  LAND
options(old.opt)
</code></pre>

<p>Now to match the before column, we need some alternatives. The first
four rows are controls, and the other rows are samples which are
indicated by a project ID (prefix RD) and then a sample ID. The
mixture samples at the bottom contain semicolon-delimited mixture
proportions.</p>

<pre><code class="r">project.pattern &lt;- list(project=&quot;RD[0-9]+-[0-9]+&quot;, &quot;-&quot;)
single.pattern &lt;- list(id=&quot;[0-9]+&quot;, as.integer)
mixture.pattern &lt;- list(
  ids.chr=&quot;[0-9_]+&quot;,
  &quot;-&quot;,
  parts.chr=&quot;[0-9;]+&quot;,
  &quot;-&quot;)
single.or.mixture &lt;- list(
  project.pattern,
  nc::alternatives(mixture.pattern, single.pattern))
control.pattern &lt;- list(control=&quot;[^-_]+&quot;)
single.mixture.control &lt;- list(&quot;[-_]&quot;, nc::alternatives(
  single.or.mixture, control.pattern))
(rest.dt &lt;- nc::capture_first_vec(
  before.dt$before, single.mixture.control, rest=&quot;.*&quot;))
#&gt;       project        ids.chr parts.chr id        control   rest
#&gt;  1:                                    NA         Ladder      -
#&gt;  2:                                    NA         Ladder      -
#&gt;  3:                                    NA    RB121514ADG       
#&gt;  4:                                    NA RB102191515LEA      -
#&gt;  5: RD12-0002                          35                     -
#&gt;  6: RD14-0003                          35                d3S30-
#&gt;  7: RD14-0003                          24                  d3a-
#&gt;  8: RD12-0002                           1                    d-
#&gt;  9: RD12-0002                           4                   d1-
#&gt; 10: RD14-0003                          15                  d2b-
#&gt; 11: RD12-0002            1_2       1;9 NA                      
#&gt; 12: RD14-0003 35_36_37_38_39 1;4;4;4;1 NA                M2I35-
</code></pre>

<p>The rest may contain some information related to the dilution and
treatment, which we can parse as follows:</p>

<pre><code class="r">dilution.pattern &lt;- nc::quantifier(
  &quot;[dM]&quot;,
  dilution.number=&quot;[0-9]?&quot;, as.integer,
  &quot;?&quot;)
treatment.pattern &lt;- nc::quantifier(
  treatment.letter=&quot;[a-zA-Z]&quot;,
  nc::quantifier(treatment.number=&quot;[0-9]+&quot;, as.integer, &quot;?&quot;),
  &quot;?&quot;)
dilution.treatment &lt;- list(
  dilution.pattern,
  treatment.pattern,
  &quot;[_-]?&quot;)
nc::capture_first_vec(rest.dt$rest, &quot;^&quot;, dilution.treatment, &quot;$&quot;)
#&gt;     dilution.number treatment.letter treatment.number
#&gt;  1:              NA                                NA
#&gt;  2:              NA                                NA
#&gt;  3:              NA                                NA
#&gt;  4:              NA                                NA
#&gt;  5:              NA                                NA
#&gt;  6:               3                S               30
#&gt;  7:               3                a               NA
#&gt;  8:              NA                                NA
#&gt;  9:               1                                NA
#&gt; 10:               2                b               NA
#&gt; 11:              NA                                NA
#&gt; 12:               2                I               35
</code></pre>

<p>Now we just have to put all of those patterns together to get a full
match:</p>

<pre><code class="r">fsa.pattern &lt;- list(
  well.pattern,
  single.mixture.control,
  dilution.treatment,
  mass.pattern, kit.pattern, q.pattern,  
  end.pattern)
(match.dt &lt;- nc::capture_first_vec(fsa.vec, fsa.pattern))
#&gt;     well.letter well.number   project        ids.chr parts.chr id
#&gt;  1:           A           1                                    NA
#&gt;  2:           D           7                                    NA
#&gt;  3:           A          12                                    NA
#&gt;  4:           A          10                                    NA
#&gt;  5:           A           2 RD12-0002                          35
#&gt;  6:           G           1 RD14-0003                          35
#&gt;  7:           A           6 RD14-0003                          24
#&gt;  8:           A           8 RD12-0002                           1
#&gt;  9:           A          10 RD12-0002                           4
#&gt; 10:           C           2 RD14-0003                          15
#&gt; 11:           A           2 RD12-0002            1_2       1;9 NA
#&gt; 12:           H           7 RD14-0003 35_36_37_38_39 1;4;4;4;1 NA
#&gt;            control dilution.number treatment.letter treatment.number
#&gt;  1:         Ladder              NA                                NA
#&gt;  2:         Ladder              NA                                NA
#&gt;  3:    RB121514ADG              NA                                NA
#&gt;  4: RB102191515LEA              NA                                NA
#&gt;  5:                             NA                                NA
#&gt;  6:                              3                S               30
#&gt;  7:                              3                a               NA
#&gt;  8:                             NA                                NA
#&gt;  9:                              1                                NA
#&gt; 10:                              2                b               NA
#&gt; 11:                             NA                                NA
#&gt; 12:                              2                I               35
#&gt;     template.nanograms  kit Q.chr capillary seconds
#&gt;  1:                 NA PP16               1      10
#&gt;  2:                 NA   IP               4       5
#&gt;  3:                 NA                    1      10
#&gt;  4:                 NA   IP               1      10
#&gt;  5:            0.50000 PP16               1      10
#&gt;  6:            0.01563    P  10.0         3      10
#&gt;  7:            0.06250   IP   0.8         1      10
#&gt;  8:            0.12500 PP16               1      10
#&gt;  9:            0.06250 PP16               1      10
#&gt; 10:            0.25000   IP   0.5         3       5
#&gt; 11:            0.12500 PP16               1      10
#&gt; 12:            0.75000   IP  LAND         4       5
</code></pre>

<p>And to verify we parsed everything correctly we print the subjects
next to each row:</p>

<pre><code class="r">disp.dt &lt;- data.table::data.table(match.dt)
names(disp.dt) &lt;- paste(1:ncol(disp.dt))
old.opt &lt;- options(&quot;datatable.print.colnames&quot;=&quot;none&quot;)
split(disp.dt, fsa.vec)
#&gt; $`A01-Ladder-PP16-001.10sec.fsa`
#&gt; 1: A 1       NA Ladder NA   NA NA PP16     1 10
#&gt; 
#&gt; $`A02-RD12-0002-1_2-1;9-0.125PP16-001.10sec.fsa`
#&gt; 1: A 2 RD12-0002 1_2 1;9 NA   NA   NA 0.125 PP16     1 10
#&gt; 
#&gt; $`A02-RD12-0002-35-0.5PP16-001.10sec.fsa`
#&gt; 1: A 2 RD12-0002     35   NA   NA 0.5 PP16     1 10
#&gt; 
#&gt; $`A06_RD14-0003-24d3a-0.0625IP-Q0.8_001.10sec.fsa`
#&gt; 1: A 6 RD14-0003     24   3 a NA 0.0625 IP 0.8  1 10
#&gt; 
#&gt; $`A08-RD12-0002-01d-0.125PP16-001.10sec.fsa`
#&gt; 1: A 8 RD12-0002     1   NA   NA 0.125 PP16     1 10
#&gt; 
#&gt; $`A10-RD12-0002-04d1-0.0625PP16-001.10sec.fsa`
#&gt; 1: A 10 RD12-0002     4   1   NA 0.0625 PP16     1 10
#&gt; 
#&gt; $`A10_RB102191515LEA-IP_001.10sec.fsa`
#&gt; 1: A 10       NA RB102191515LEA NA   NA NA IP     1 10
#&gt; 
#&gt; $A12_RB121514ADG_001.10sec.fsa
#&gt; 1: A 12       NA RB121514ADG NA   NA NA        1 10
#&gt; 
#&gt; $`C02_RD14-0003-15d2b-0.25IP-Q0.5_003.5sec.fsa`
#&gt; 1: C 2 RD14-0003     15   2 b NA 0.25 IP 0.5  3  5
#&gt; 
#&gt; $`D07_Ladder-IP_004.5sec.fsa`
#&gt; 1: D 7       NA Ladder NA   NA NA IP     4  5
#&gt; 
#&gt; $`G01_RD14-0003-35d3S30-0.01563P-Q10.0_003.10sec.fsa`
#&gt; 1: G 1 RD14-0003     35   3 S 30 0.01563  P 10.0  3 10
#&gt; 
#&gt; $`H07_RD14-0003-35_36_37_38_39-1;4;4;4;1-M2I35-0.75IP-QLAND_004.5sec.fsa`
#&gt; 1: H 7 RD14-0003 35_36_37_38_39 1;4;4;4;1 NA   2 I 35 0.75 IP LAND  4  5
options(old.opt)
</code></pre>

<p>Incidentally, if you print the regex as a string it looks like
something that would be essentially impossible to write/maintain by
hand (without <code>nc</code> helper functions):</p>

<pre><code class="r">nc::var_args_list(fsa.pattern)$pattern
#&gt; [1] &quot;(?:(?:^([A-H])([0-9]+))(?:[-_](?:(?:(?:(RD[0-9]+-[0-9]+)-)(?:(?:([0-9_]+)-([0-9;]+)-)|(?:([0-9]+))))|(?:([^-_]+))))(?:(?:(?:[dM]([0-9]?))?)(?:(?:([a-zA-Z])(?:(?:([0-9]+))?))?)[_-]?)(?:([0-9.]*))(?:(?:(PP16|IP|P))?)(?:(?:-Q(LAND|[0-9.]+))?)(?:[-_]([0-9]+)[.]([0-9]+)sec[.]fsa$))&quot;
</code></pre>

<p>In conclusion, we have shown how <code>nc</code> can help build complex regex
patterns from simple, understandable sub-patterns in R code. The
general workflow we have followed in this section can be generalized
to other projects. First, identify a small set of subjects to use for
testing (<code>fsa.vec</code> in the code above). Second, create some
sub-patterns for the start/end of the subjects, and create a
sub-pattern that will capture everything else in between. Third,
create some more sub-patterns to match the &ldquo;everything else&rdquo; in the
previous step (e.g. <code>before.dt$before</code>, <code>between.dt$between</code>,
<code>rest.dt$rest</code> above). Repeat the process until there is nothing left
to match, and then concatenate the sub-patterns to match the whole
subject.</p>

</body>

</html>
