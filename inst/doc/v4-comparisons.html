<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Comparisons with other packages</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{vignette 4: comparisons with other packages}
-->

<h1>Comparisons with other packages</h1>

<p>This vignette provides comparisons with other packages that provide
similar functionality. This is a work in progress &ndash; for a more
detailed / complete / coherent comparison with other packages which
provide wide-to-tall data reshaping, see <a href="https://github.com/tdhock/nc-article#paper">my
paper</a>.</p>

<h2>Are sepals larger or smaller than petals in the iris data?</h2>

<p>Sometimes you want to melt a &ldquo;wide&rdquo; data table which has several
distinct pieces of information encoded in each column name. One
example is the familiar iris data, which have flower part and
measurement dimension encoded in each of four column names:</p>

<pre><code class="r">
library(data.table)
data.table(iris)
#&gt;      Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
#&gt;   1:          5.1         3.5          1.4         0.2    setosa
#&gt;   2:          4.9         3.0          1.4         0.2    setosa
#&gt;   3:          4.7         3.2          1.3         0.2    setosa
#&gt;   4:          4.6         3.1          1.5         0.2    setosa
#&gt;   5:          5.0         3.6          1.4         0.2    setosa
#&gt;  ---                                                            
#&gt; 146:          6.7         3.0          5.2         2.3 virginica
#&gt; 147:          6.3         2.5          5.0         1.9 virginica
#&gt; 148:          6.5         3.0          5.2         2.0 virginica
#&gt; 149:          6.2         3.4          5.4         2.3 virginica
#&gt; 150:          5.9         3.0          5.1         1.8 virginica
</code></pre>

<p>The goal in this section will be to convert these data into a format
with a column for each flower part (<code>Sepal</code> and <code>Petal</code>) so we can
easily make a facetted scatterplot to visually examine whether or not
sepals or larger than petals. The easiest way to perform this
conversion is with packages which provide a function for melting into
multiple output columns:</p>

<pre><code class="r">
iris.parts &lt;- list(
  nc=nc::capture_melt_multiple(
    iris,
    column=&quot;.*?&quot;,
    &quot;[.]&quot;,
    dim=&quot;.*&quot;),
  tidyr=if(requireNamespace(&quot;tidyr&quot;))tidyr::pivot_longer(
    iris, 
    cols=1:4, 
    names_to=c(&quot;.value&quot;, &quot;dim&quot;),
    names_sep=&quot;[.]&quot;),
  stats=stats::reshape(
    iris,
    direction=&quot;long&quot;,
    timevar=&quot;dim&quot;,
    varying=1:4,
    sep=&quot;.&quot;),
  &quot;data.table::melt&quot;=melt(
    data.table(iris),
    measure.vars=patterns(
      Sepal=&quot;^Sepal&quot;,
      Petal=&quot;^Petal&quot;)
  )[data.table(
    variable=factor(1:2), dim=c(&quot;Length&quot;, &quot;Width&quot;)
  ), on=.(variable)],
  if(requireNamespace(&quot;cdata&quot;))cdata::rowrecs_to_blocks(
    iris,
    controlTable=data.frame(
      dim=c(&quot;Length&quot;, &quot;Width&quot;),
      Petal=c(&quot;Petal.Length&quot;, &quot;Petal.Width&quot;),
      Sepal=c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;),
      stringsAsFactors=FALSE),
    columnsToCopy=&quot;Species&quot;))
#&gt; Loading required namespace: cdata
iris.parts$nc
#&gt;        Species    dim Petal Sepal
#&gt;   1:    setosa Length   1.4   5.1
#&gt;   2:    setosa Length   1.4   4.9
#&gt;   3:    setosa Length   1.3   4.7
#&gt;   4:    setosa Length   1.5   4.6
#&gt;   5:    setosa Length   1.4   5.0
#&gt;  ---                             
#&gt; 296: virginica  Width   2.3   3.0
#&gt; 297: virginica  Width   1.9   2.5
#&gt; 298: virginica  Width   2.0   3.0
#&gt; 299: virginica  Width   2.3   3.4
#&gt; 300: virginica  Width   1.8   3.0
</code></pre>

<p>It is clear from the code above that each package is capable of
the conversions. However the syntax and level of explicitness varies:</p>

<ul>
<li><code>nc::capture_melt_multiple</code> requires a regular
expression: (most implicit, least repetition)

<ul>
<li>any input column names that match the regex are melted.</li>
<li>values matched in the <code>column</code> group are used for the output column names.</li>
</ul></li>
<li><code>tidyr::pivot_longer</code> and <code>stats::reshape</code> require specification of
the input columns to melt along with a separator.

<ul>
<li><code>stats::reshape</code> assumes the output columns names occur in the
part of the input column name before the separator.</li>
<li><code>tidyr::pivot_longer</code> assumes the output columns occur in the part
which corresponds to the <code>.value</code> element of the <code>names_to</code>
argument.</li>
</ul></li>
<li><code>data.table::melt</code> requires a join to recover the <code>dim</code> output
column.</li>
<li><code>cdata::rowrecs_to_blocks</code> requires explicit specification of a
control table. (most explicit, most repetition)</li>
</ul>

<p>Any of the results can be visualized via:</p>

<pre><code class="r">
if(require(ggplot2)){
  ggplot()+
    theme_bw()+
    theme(panel.spacing=grid::unit(0, &quot;lines&quot;))+
    facet_grid(dim ~ Species)+
    coord_equal()+
    geom_abline(slope=1, intercept=0, color=&quot;grey&quot;)+
    geom_point(aes(
      Petal, Sepal),
      data=iris.parts$nc)
}
</code></pre>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfgAAAH4CAMAAACR9g9NAAAAGFBMVEUAAAAaGhozMzNNTU2+vr7Z2dnr6+v///+pWi9sAAAACXBIWXMAAAsSAAALEgHS3X78AAAWOklEQVR4nO2di3bjOK5F5bZS+v8/nvFDb5ACSICgjHPW3KpcNlXe4A4l2UHsYUJCZvAGQHwC8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UED8UGTFf8f8gMpEf/XZYAlCcRbp1csiDdOr1ie4h9a/9A7eiv8IL8sTD3W4/iVxrpBfD49iDeJi/jH472ij////fryb/67spRynvV/b5LHF3HG/PyH5lh/K9Oba/7zC1W3ZB7i367nmpY1rTZfKX6V/jf/+R39q1pkFfGPPY3Cknnt+MdjFb/8/3WpFT9bf1DiPbAODEfxdUvmc43/ruRc0eabuKaUOpyv683CdiF+efjH4yj+djt+vq7vrqX15iuwHl+sx5lr+csB6+9vZ3j7bfh4VC4ZnsdbRwtL4fZ3G4i3Tq9YEG+cXrEg3ji9YkG8cXrFgnjj9IpVIh75xaTFP59f8a8//hETtMdkB5tg1f+D1Vg2S306EaXFP9//myA+mnjseB8sd/GfHf+6GvzrMsBKZxiGwwhO9ZoIJlgKNQ2vHLBwqldEMMHyFz8H4ptiQfzFGMRTYx/j65+vq/0bC+IVEUywqg7e7vVhzhsL4hURTLC0xA8Qb4ZggqUkfoB4OwQTLI1r/DSLxzXeBMEES6mmde9DvDqCCZbSjp+WryBeHcEES+vm7oAF8YoIJlj14g/uIV4dwQRLRfxwnAfxmggmWKUHf+/hIb4BgglW4cHD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80RdLB3xZTRXlTiJL29kK8TajGXumZWxVMSX0VxW4iO+opGtEGvN+Sy6TNTG8hN/XYnuCu94uVjtxC/3ybR4daxK8VOxeEYlqiu8X1MuVjPxwznbifpYlXf1u9eYJI/MqcRBfF0jWwHWnLT310QDrMrn8aWPzKrEQvyUFV/ZyFaANSftfaruryOxal/AKXtkXiV6K3xaVC5WG/HEeX4r3gSrVvx2JvuRmZWorfB5TblYTcRT3jfraoNVIv7Vs7UAunSMUck0tx3WtBesOZR3cyyHHU/21/nveIW2PyHWnIv9Xo1AYlXe1Rdc4/mVGF3jJVgtxGfP9Br9dSRW7fN48SMLKrHY8UKsBuI/WAnzKv11JFa5+HM/KOeRJZXorDC5oFwsZ/E6/XUkVoX4kkcWVaKywvSKcrF8xSv115FYbcXLKmkmXqvtT4C1jH2Z0t5/Qbywklbi1dr+BFjz2Iy0wh29/4B4aSUm4mVYrcRv8GZKvf46EquheHElFuKFWI3EbwG/mIr9dSRWO/HySnRW+EK8ZtufBGtzjT/0Chy83118QSUtdrxq258Aaz92AlTtryOxqsQP+2fyuUcuqURZPNU6oNv2J8A6jGW8dyh+u4UuHrmoEu0dX4DVSnwG69biyyoxONVLsVqIv8C6s/jCSvTEn36YyMVqIP4Kq0Px3Gt8aSWK4o8dQ1wsB/H6/XUklkD88/BWKNxHKa5EU/x0WmGDtj8BVlK8QX8dicUX/5zfBEcovrwSnRVel3V3MbVo+5NgJa7xFv11JJboVF8ivqIS5R1fgtVC/AVWB+Jf3pf3uWPGpmOMSgLrLf406o5FpyGW5Br//VvyPczur2u7443a/gRY/NVy3/Gfd7achKXUEGpf4wuwGou3QSCxqp7OXT5KXaeg2Qpbtf2ZYN1RfGWnoNUKm7X9mWDdUHxtp6DRCtu1/ZlgdSQe+cVci//Yv5xhM+9iYuOH487rFOsciNf9BzvFOudaPPKTgfiguRQ//6ROa976uuDlP5ibyH44/kTuv9cl1gXXOVfin8yH5s6buPPys9gPx+e6NRZ78Zdoiec/NvM782JnCUrlPh5zWpdY4g2vKJ5PqHAK0T/B3BtL9C33jpp4/sNqVKL+/XhzLH3xglNg00uC4BSofcYq/6/becpYgpvrT/B0LmggPmggPmggPmggPmhCit92ZQ6Hv6MkWr3vDNNZeLSFiFbvO1/x85tSfH7lzhuqcaLV+84wq16ED+EWIlq976y/Wvnd/QPEh8iw/3PAjg+SvXKID5Nv0d+3l3z/H/HbV7+daPUi30B80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80EB80PwPpF/2yxrFseMAAAAASUVORK5CYII=" alt="plot of chunk unnamed-chunk-3"/></p>

<p>It is clear from the plot above that sepals are larger than petals,
for every measured flower. </p>

<h2>Comparing dimensions in iris data</h2>

<p>What if we wanted to compare dimensions rather than parts? </p>

<pre><code class="r">
iris.dims &lt;- list(
  nc=nc::capture_melt_multiple(
    iris,
    part=&quot;.*?&quot;,
    &quot;[.]&quot;,
    column=&quot;.*&quot;),
  stats=stats::reshape(
    structure(iris, names=sub(&quot;(.*?)[.](.*)&quot;, &quot;\\2.\\1&quot;, names(iris))),
    direction=&quot;long&quot;,
    timevar=&quot;part&quot;,
    varying=1:4,
    sep=&quot;.&quot;))
iris.dims$nc
#&gt;        Species  part Length Width
#&gt;   1:    setosa Petal    1.4   0.2
#&gt;   2:    setosa Petal    1.4   0.2
#&gt;   3:    setosa Petal    1.3   0.2
#&gt;   4:    setosa Petal    1.5   0.2
#&gt;   5:    setosa Petal    1.4   0.2
#&gt;  ---                             
#&gt; 296: virginica Sepal    6.7   3.0
#&gt; 297: virginica Sepal    6.3   2.5
#&gt; 298: virginica Sepal    6.5   3.0
#&gt; 299: virginica Sepal    6.2   3.4
#&gt; 300: virginica Sepal    5.9   3.0
</code></pre>

<p>The code above shows that the syntax is mostly the same for this
example. The biggest difference is for <code>stats::reshape</code> which assumes
that each input column name is composed of (1) the output column name,
(2) a delimiter, and (3) some additional information to be stored in
the output column given by <code>timevar</code>. Therefore we need to pre-process
column names using <code>sub</code> for it to work.</p>

<pre><code class="r">
if(require(ggplot2)){
  ggplot()+
    theme_bw()+
    theme(panel.spacing=grid::unit(0, &quot;lines&quot;))+
    facet_grid(part ~ Species)+
    coord_equal()+
    geom_abline(slope=1, intercept=0, color=&quot;grey&quot;)+
    geom_point(aes(
      Length, Width),
      data=iris.dims$nc)
}
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-5"/></p>

<p>It is clear from the plot above that <code>Length</code> is larger than <code>Width</code>
for every measured flower part.</p>

<h2>Do columns need to be sorted?</h2>

<p>Consider the following wide data set:</p>

<pre><code class="r">
TC &lt;- data.table::data.table(
  age.treatment=c(1, 5),
  sex.control=c(&quot;M&quot;, &quot;M&quot;),
  sex.treatment=c(&quot;F&quot;, &quot;F&quot;),
  age.control=c(10, 50))
</code></pre>

<p>It is clear from the column names how the data should be grouped when
they are converted to tall format. However the columns do not appear
in regular order (age is before sex for treatment, but age is after
sex for control), which causes a problem for stats and data.table:</p>

<pre><code class="r">
input.list &lt;- list(
  &quot;nc&quot;=nc::capture_melt_multiple(
    TC,
    column=&quot;.*?&quot;,
    &quot;[.]&quot;,
    group=&quot;.*&quot;),
  &quot;cdata&quot;=if(requireNamespace(&quot;cdata&quot;))cdata::rowrecs_to_blocks(
    TC,
    controlTable=data.frame(
      group=c(&quot;treatment&quot;, &quot;control&quot;),
      age=c(&quot;age.treatment&quot;, &quot;age.control&quot;),
      sex=c(&quot;sex.treatment&quot;, &quot;sex.control&quot;),
      stringsAsFactors=FALSE)),
  &quot;data.table&quot;=data.table::melt(TC, measure.vars=patterns(
    age=&quot;age&quot;,
    sex=&quot;sex&quot;)),
  &quot;stats&quot;=stats::reshape(
    TC,
    varying=1:4,
    direction=&quot;long&quot;),
  &quot;tidyr&quot;=if(requireNamespace(&quot;tidyr&quot;))tidyr::pivot_longer(
    TC, 1:4,
    names_to=c(&quot;.value&quot;, &quot;group&quot;),
    names_sep=&quot;[.]&quot;))
output.list &lt;- list()
for(pkg in names(input.list)){
  df.or.null &lt;- input.list[[pkg]]
  if(is.data.frame(df.or.null)){
    output.list[[pkg]] &lt;- data.table::data.table(df.or.null)[order(age)]
  }
}
output.list
#&gt; $nc
#&gt;        group age sex
#&gt; 1: treatment   1   F
#&gt; 2: treatment   5   F
#&gt; 3:   control  10   M
#&gt; 4:   control  50   M
#&gt; 
#&gt; $cdata
#&gt;        group age sex
#&gt; 1: treatment   1   F
#&gt; 2: treatment   5   F
#&gt; 3:   control  10   M
#&gt; 4:   control  50   M
#&gt; 
#&gt; $data.table
#&gt;    variable age sex
#&gt; 1:        1   1   M
#&gt; 2:        1   5   M
#&gt; 3:        2  10   F
#&gt; 4:        2  50   F
#&gt; 
#&gt; $stats
#&gt;         time age sex id
#&gt; 1: treatment   1   M  1
#&gt; 2: treatment   5   M  2
#&gt; 3:   control  10   F  1
#&gt; 4:   control  50   F  2
#&gt; 
#&gt; $tidyr
#&gt;        group age sex
#&gt; 1: treatment   1   F
#&gt; 2: treatment   5   F
#&gt; 3:   control  10   M
#&gt; 4:   control  50   M
sapply(output.list, function(DT)identical(DT$sex, c(&quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;)))
#&gt;         nc      cdata data.table      stats      tidyr 
#&gt;       TRUE       TRUE      FALSE      FALSE       TRUE
</code></pre>

<p>In conclusion, when the input column names to melt do not appear in
the same order across groups or output columns, then the correct tall
data can be computed using one of <code>nc::capture_melt_multiple</code>,
<code>tidyr::pivot_longer</code>, <code>cdata::rowrecs_to_blocks</code>.</p>

<h2>Melting into a single output column, who data</h2>

<p>Another data set where it is useful to do column name pattern matching
followed by melting is the World Health Organization data:</p>

<pre><code class="r">
if(requireNamespace(&quot;tidyr&quot;)){
  data(who, package=&quot;tidyr&quot;)
}else{
  who &lt;- data.frame(id=1, new_sp_m5564=2, newrel_f65=3)
}
names(who)
#&gt;  [1] &quot;country&quot;      &quot;iso2&quot;         &quot;iso3&quot;         &quot;year&quot;         &quot;new_sp_m014&quot; 
#&gt;  [6] &quot;new_sp_m1524&quot; &quot;new_sp_m2534&quot; &quot;new_sp_m3544&quot; &quot;new_sp_m4554&quot; &quot;new_sp_m5564&quot;
#&gt; [11] &quot;new_sp_m65&quot;   &quot;new_sp_f014&quot;  &quot;new_sp_f1524&quot; &quot;new_sp_f2534&quot; &quot;new_sp_f3544&quot;
#&gt; [16] &quot;new_sp_f4554&quot; &quot;new_sp_f5564&quot; &quot;new_sp_f65&quot;   &quot;new_sn_m014&quot;  &quot;new_sn_m1524&quot;
#&gt; [21] &quot;new_sn_m2534&quot; &quot;new_sn_m3544&quot; &quot;new_sn_m4554&quot; &quot;new_sn_m5564&quot; &quot;new_sn_m65&quot;  
#&gt; [26] &quot;new_sn_f014&quot;  &quot;new_sn_f1524&quot; &quot;new_sn_f2534&quot; &quot;new_sn_f3544&quot; &quot;new_sn_f4554&quot;
#&gt; [31] &quot;new_sn_f5564&quot; &quot;new_sn_f65&quot;   &quot;new_ep_m014&quot;  &quot;new_ep_m1524&quot; &quot;new_ep_m2534&quot;
#&gt; [36] &quot;new_ep_m3544&quot; &quot;new_ep_m4554&quot; &quot;new_ep_m5564&quot; &quot;new_ep_m65&quot;   &quot;new_ep_f014&quot; 
#&gt; [41] &quot;new_ep_f1524&quot; &quot;new_ep_f2534&quot; &quot;new_ep_f3544&quot; &quot;new_ep_f4554&quot; &quot;new_ep_f5564&quot;
#&gt; [46] &quot;new_ep_f65&quot;   &quot;newrel_m014&quot;  &quot;newrel_m1524&quot; &quot;newrel_m2534&quot; &quot;newrel_m3544&quot;
#&gt; [51] &quot;newrel_m4554&quot; &quot;newrel_m5564&quot; &quot;newrel_m65&quot;   &quot;newrel_f014&quot;  &quot;newrel_f1524&quot;
#&gt; [56] &quot;newrel_f2534&quot; &quot;newrel_f3544&quot; &quot;newrel_f4554&quot; &quot;newrel_f5564&quot; &quot;newrel_f65&quot;
</code></pre>

<p>Each column which starts with <code>new</code> has three distinct pieces of
information encoded in its name: diagnosis type (e.g. sp or rel),
gender (m or f), and age range (e.g. 5564 or 1524). We would like to
use a regex to match these column names, then using the matching
columns as measure.vars in a melt, then join the two results. The most
convenient way to do that is via:</p>

<pre><code class="r">
who.chr.list &lt;- list(
  nc=nc::capture_melt_single(
    who,
    &quot;new_?&quot;,
    diagnosis=&quot;.*&quot;,
    &quot;_&quot;,
    gender=&quot;.&quot;,
    ages=&quot;.*&quot;),
  tidyr=if(requireNamespace(&quot;tidyr&quot;))tidyr::pivot_longer(
    who,
    new_sp_m014:newrel_f65,
    names_to=c(&quot;diagnosis&quot;, &quot;gender&quot;, &quot;ages&quot;),
    names_pattern=&quot;new_?(.*)_(.)(.*)&quot;))
</code></pre>

<p>Note the result includes additional column <code>value</code> which contains the
melted data. There is also a column for each capture group in the
specified pattern. The following example shows how to rename the
<code>value</code> column, remove missing values, and use numeric type conversion
functions:</p>

<pre><code class="r">
who.pattern &lt;- &quot;new_?(.*)_(.)((0|[0-9]{2})([0-9]{0,2}))&quot;
as.numeric.Inf &lt;- function(y)ifelse(y==&quot;&quot;, Inf, as.numeric(y))
who.typed.list &lt;- list(
  nc=nc::capture_melt_single(
    who,
    &quot;new_?&quot;,
    diagnosis=&quot;.*&quot;,
    &quot;_&quot;,
    gender=&quot;.&quot;,
    ages=list(
      ymin.num=&quot;0|[0-9]{2}&quot;, as.numeric,
      ymax.num=&quot;[0-9]{0,2}&quot;, as.numeric.Inf),
    value.name=&quot;count&quot;,
    na.rm=TRUE),
  tidyr=if(requireNamespace(&quot;tidyr&quot;))try(tidyr::pivot_longer(
    who,
    cols=grep(who.pattern, names(who)),
    names_transform=list(
      ymin.num=as.numeric,
      ymax.num=as.numeric.Inf),
    names_to=c(&quot;diagnosis&quot;, &quot;gender&quot;, &quot;ages&quot;, &quot;ymin.num&quot;, &quot;ymax.num&quot;),
    names_pattern=who.pattern,
    values_drop_na=TRUE,
    values_to=&quot;count&quot;)))
str(who.typed.list)
#&gt; List of 2
#&gt;  $ nc   :Classes &#39;data.table&#39; and &#39;data.frame&#39;:  76046 obs. of  10 variables:
#&gt;   ..$ country  : chr [1:76046] &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; ...
#&gt;   ..$ iso2     : chr [1:76046] &quot;AF&quot; &quot;AF&quot; &quot;AF&quot; &quot;AF&quot; ...
#&gt;   ..$ iso3     : chr [1:76046] &quot;AFG&quot; &quot;AFG&quot; &quot;AFG&quot; &quot;AFG&quot; ...
#&gt;   ..$ year     : int [1:76046] 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 ...
#&gt;   ..$ diagnosis: chr [1:76046] &quot;sp&quot; &quot;sp&quot; &quot;sp&quot; &quot;sp&quot; ...
#&gt;   ..$ gender   : chr [1:76046] &quot;m&quot; &quot;m&quot; &quot;m&quot; &quot;m&quot; ...
#&gt;   ..$ ages     : chr [1:76046] &quot;014&quot; &quot;014&quot; &quot;014&quot; &quot;014&quot; ...
#&gt;   ..$ ymin.num : num [1:76046] 0 0 0 0 0 0 0 0 0 0 ...
#&gt;   ..$ ymax.num : num [1:76046] 14 14 14 14 14 14 14 14 14 14 ...
#&gt;   ..$ count    : int [1:76046] 0 30 8 52 129 90 127 139 151 193 ...
#&gt;   ..- attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; 
#&gt;  $ tidyr: tibble [76,046 Ã— 10] (S3: tbl_df/tbl/data.frame)
#&gt;   ..$ country  : chr [1:76046] &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; ...
#&gt;   ..$ iso2     : chr [1:76046] &quot;AF&quot; &quot;AF&quot; &quot;AF&quot; &quot;AF&quot; ...
#&gt;   ..$ iso3     : chr [1:76046] &quot;AFG&quot; &quot;AFG&quot; &quot;AFG&quot; &quot;AFG&quot; ...
#&gt;   ..$ year     : int [1:76046] 1997 1997 1997 1997 1997 1997 1997 1997 1997 1997 ...
#&gt;   ..$ diagnosis: chr [1:76046] &quot;sp&quot; &quot;sp&quot; &quot;sp&quot; &quot;sp&quot; ...
#&gt;   ..$ gender   : chr [1:76046] &quot;m&quot; &quot;m&quot; &quot;m&quot; &quot;m&quot; ...
#&gt;   ..$ ages     : chr [1:76046] &quot;014&quot; &quot;1524&quot; &quot;2534&quot; &quot;3544&quot; ...
#&gt;   ..$ ymin.num : num [1:76046] 0 15 25 35 45 55 65 0 15 25 ...
#&gt;   ..$ ymax.num : num [1:76046] 14 24 34 44 54 ...
#&gt;   ..$ count    : int [1:76046] 0 10 6 3 5 2 0 5 38 36 ...
</code></pre>

<p>The result above shows that <code>nc::capture_melt_single</code> (1) makes it
easier to define complex patterns (2) supports type conversion without
a post-processing step, and (3) reduces repetition in user code. There
are several sources of repetition in <code>tidyr</code> code:</p>

<ul>
<li>Syntax of type conversion:

<ul>
<li>capture group name <code>ymin.num</code> appears only once for <code>nc</code> but twice for <code>tidyr</code>.</li>
<li>capture group name <code>ymax.chr</code> appears only once for <code>nc</code> but three times for <code>tidyr</code>.</li>
</ul></li>
<li>Specification of input data and columns to melt:

<ul>
<li>input data table <code>who</code> appears only once for <code>nc</code> but twice for <code>tidyr</code>.</li>
<li>pattern for input columns to melt appears only once for <code>nc</code> but twice for <code>tidyr</code>.</li>
</ul></li>
</ul>

<p>Other packages for doing this include:</p>

<pre><code class="r">
if(requireNamespace(&quot;tidyr&quot;)){
  gather.result &lt;- tidyr::gather(
    who,
    &quot;variable&quot;,
    &quot;count&quot;,
    grep(who.pattern, names(who)),
    na.rm=TRUE)
  extract.result &lt;- tidyr::extract(
    gather.result,
    &quot;variable&quot;,
    c(&quot;diagnosis&quot;, &quot;gender&quot;, &quot;ages&quot;, &quot;ymin.int&quot;, &quot;ymax.int&quot;),
    who.pattern,
    convert=TRUE)
  transform.result &lt;- base::transform(
    extract.result,
    ymin.num=as.numeric(ymin.int),
    ymax.num=ifelse(is.na(ymax.int), Inf, as.numeric(ymax.int)))
  str(transform.result)
}
#&gt; &#39;data.frame&#39;:    76046 obs. of  12 variables:
#&gt;  $ country  : chr  &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; ...
#&gt;  $ iso2     : chr  &quot;AF&quot; &quot;AF&quot; &quot;AF&quot; &quot;AF&quot; ...
#&gt;  $ iso3     : chr  &quot;AFG&quot; &quot;AFG&quot; &quot;AFG&quot; &quot;AFG&quot; ...
#&gt;  $ year     : int  1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 ...
#&gt;  $ diagnosis: chr  &quot;sp&quot; &quot;sp&quot; &quot;sp&quot; &quot;sp&quot; ...
#&gt;  $ gender   : chr  &quot;m&quot; &quot;m&quot; &quot;m&quot; &quot;m&quot; ...
#&gt;  $ ages     : int  14 14 14 14 14 14 14 14 14 14 ...
#&gt;  $ ymin.int : int  0 0 0 0 0 0 0 0 0 0 ...
#&gt;  $ ymax.int : int  14 14 14 14 14 14 14 14 14 14 ...
#&gt;  $ count    : int  0 30 8 52 129 90 127 139 151 193 ...
#&gt;  $ ymin.num : num  0 0 0 0 0 0 0 0 0 0 ...
#&gt;  $ ymax.num : num  14 14 14 14 14 14 14 14 14 14 ...
</code></pre>

<p>Note that <code>tidyr::gather</code> requires two post-processing steps, which cause the
same two types of repetition as <code>tidyr::pivot_longer</code>:</p>

<ul>
<li>Syntax of type conversion:
<code>base::transform</code> is used for converting age range variables to
numeric, since default types are int with <code>convert=TRUE</code>.</li>
<li>Specification of input data and columns to melt:
<code>tidyr::extract</code> is used to convert the melted column into
several output columns; this results in repetition in the code
because the regex is also used to define the columns to melt/gather.</li>
</ul>

<p>The <code>reshape2</code> package suffers from the same two issues:</p>

<pre><code class="r">
reshape2.result &lt;- if(requireNamespace(&quot;reshape2&quot;)){
  reshape2:::melt.data.frame(
    who,
    measure.vars=grep(who.pattern, names(who)),
    na.rm=TRUE,
    value.name=&quot;count&quot;)
}
#&gt; Loading required namespace: reshape2
</code></pre>

<p>Interestingly, <code>data.table::patterns</code> can be used to avoid repeating
the data set name, <code>who</code>. However it supports neither type conversion
nor regex capture groups.</p>

<pre><code class="r">
dt.result &lt;- data.table::melt.data.table(
  data.table(who),
  measure.vars=patterns(who.pattern),
  na.rm=TRUE,
  value.name=&quot;count&quot;)
</code></pre>

<p>Neither cdata nor stats provide an na.rm option:</p>

<pre><code class="r">
who.df &lt;- data.frame(who)
is.varying &lt;- grepl(who.pattern, names(who))
names(who.df)[is.varying] &lt;- paste0(&quot;count.&quot;, names(who)[is.varying])
stats.result &lt;- stats::reshape(
  who.df,
  direction=&quot;long&quot;,
  timevar=&quot;variable&quot;,
  varying=is.varying)
</code></pre>

<pre><code class="r">
if(requireNamespace(&quot;cdata&quot;)){
  cdata.result &lt;- cdata::rowrecs_to_blocks(
    who, 
    cdata::build_unpivot_control(
      &quot;variable&quot;,
      &quot;count&quot;,
      grep(who.pattern, names(who), value=TRUE)),
    columnsToCopy=grep(who.pattern, names(who), value=TRUE, invert=TRUE))
}
</code></pre>

<h2>Melting a wider iris back to original</h2>

<pre><code class="r">
## Example 1: melting a wider iris data back to original.
library(data.table)
iris.dt &lt;- data.table(
  i=1:nrow(iris),
  iris[,1:4],
  Species=paste(iris$Species))
print(iris.dt)
#&gt;        i Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
#&gt;   1:   1          5.1         3.5          1.4         0.2    setosa
#&gt;   2:   2          4.9         3.0          1.4         0.2    setosa
#&gt;   3:   3          4.7         3.2          1.3         0.2    setosa
#&gt;   4:   4          4.6         3.1          1.5         0.2    setosa
#&gt;   5:   5          5.0         3.6          1.4         0.2    setosa
#&gt;  ---                                                                
#&gt; 146: 146          6.7         3.0          5.2         2.3 virginica
#&gt; 147: 147          6.3         2.5          5.0         1.9 virginica
#&gt; 148: 148          6.5         3.0          5.2         2.0 virginica
#&gt; 149: 149          6.2         3.4          5.4         2.3 virginica
#&gt; 150: 150          5.9         3.0          5.1         1.8 virginica

## what if we had two observations on each row?
set.seed(1)
iris.rand &lt;- iris.dt[sample(.N)]
iris.wide &lt;- cbind(treatment=iris.rand[1:75], control=iris.rand[76:150])
print(iris.wide, topn=2, nrows=10)
#&gt;     treatment.i treatment.Sepal.Length treatment.Sepal.Width
#&gt;  1:          68                    5.8                   2.7
#&gt;  2:         129                    6.4                   2.8
#&gt; ---                                                         
#&gt; 74:          91                    5.5                   2.6
#&gt; 75:          64                    6.1                   2.9
#&gt;     treatment.Petal.Length treatment.Petal.Width treatment.Species control.i
#&gt;  1:                    4.1                   1.0        versicolor        60
#&gt;  2:                    5.6                   2.1         virginica       113
#&gt; ---                                                                         
#&gt; 74:                    4.4                   1.2        versicolor        57
#&gt; 75:                    4.7                   1.4        versicolor        72
#&gt;     control.Sepal.Length control.Sepal.Width control.Petal.Length
#&gt;  1:                  5.2                 2.7                  3.9
#&gt;  2:                  6.8                 3.0                  5.5
#&gt; ---                                                              
#&gt; 74:                  6.3                 3.3                  4.7
#&gt; 75:                  6.1                 2.8                  4.0
#&gt;     control.Petal.Width control.Species
#&gt;  1:                 1.4      versicolor
#&gt;  2:                 2.1       virginica
#&gt; ---                                    
#&gt; 74:                 1.6      versicolor
#&gt; 75:                 1.3      versicolor

## This is the usual data.table syntax for getting the original iris back.
iris.melted &lt;- melt(iris.wide, value.factor=TRUE, measure.vars = patterns(
  i=&quot;i$&quot;,
  Sepal.Length=&quot;Sepal.Length$&quot;,
  Sepal.Width=&quot;Sepal.Width$&quot;,
  Petal.Length=&quot;Petal.Length$&quot;,
  Petal.Width=&quot;Petal.Width$&quot;,
  Species=&quot;Species$&quot;))
identical(iris.melted[order(i), names(iris.dt), with=FALSE], iris.dt)
#&gt; [1] TRUE

## nc can do the same thing -- you must define an R argument named
## column, and another named argument which identifies each group.
(nc.melted &lt;- nc::capture_melt_multiple(
  iris.wide,
  group=&quot;[^.]+&quot;,
  &quot;[.]&quot;,
  column=&quot;.*&quot;))
#&gt;          group Petal.Length Petal.Width Sepal.Length Sepal.Width    Species   i
#&gt;   1:   control          3.9         1.4          5.2         2.7 versicolor  60
#&gt;   2:   control          5.5         2.1          6.8         3.0  virginica 113
#&gt;   3:   control          5.6         1.4          6.1         2.6  virginica 135
#&gt;   4:   control          1.5         0.1          4.9         3.1     setosa  10
#&gt;   5:   control          1.4         0.2          5.1         3.5     setosa   1
#&gt;  ---                                                                           
#&gt; 146: treatment          1.6         0.2          4.8         3.1     setosa  31
#&gt; 147: treatment          1.3         0.4          5.4         3.9     setosa  17
#&gt; 148: treatment          5.4         2.1          6.9         3.1  virginica 140
#&gt; 149: treatment          4.4         1.2          5.5         2.6 versicolor  91
#&gt; 150: treatment          4.7         1.4          6.1         2.9 versicolor  64
identical(nc.melted[order(i), names(iris.dt), with=FALSE], iris.dt)
#&gt; [1] TRUE

## This is how we do it using stats::reshape.
iris.wide.df &lt;- data.frame(iris.wide)
names(iris.wide.df) &lt;- sub(&quot;(.*?)[.](.*)&quot;, &quot;\\2_\\1&quot;, names(iris.wide))
iris.reshaped &lt;- stats::reshape(
  iris.wide.df,
  direction=&quot;long&quot;,
  timevar=&quot;group&quot;,
  varying=names(iris.wide.df),
  sep=&quot;_&quot;)
identical(data.table(iris.reshaped[, names(iris.dt)])[order(i)], iris.dt)
#&gt; [1] TRUE

## get the parts columns and groups -- is there any difference
## between groups? of course not!
parts.wide &lt;- nc::capture_melt_multiple(
  iris.wide,
  group=&quot;.*?&quot;,
  &quot;[.]&quot;,
  column=&quot;.*?&quot;,
  &quot;[.]&quot;,
  dim=&quot;.*&quot;)
if(require(&quot;ggplot2&quot;)){
  ggplot()+
    theme_bw()+
    theme(panel.spacing=grid::unit(0, &quot;lines&quot;))+
    facet_grid(dim ~ group)+
    coord_equal()+
    geom_abline(slope=1, intercept=0, color=&quot;grey&quot;)+
    geom_point(aes(
      Petal, Sepal),
      data=parts.wide)
}
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-16"/></p>

<h2>Lots of column types</h2>

<pre><code class="r">
## Example 2. Lots of column types, from example(melt.data.table).
DT &lt;- data.table(
  i_1 = c(1:5, NA),
  i_2 = c(NA,6:10),
  f_1 = factor(sample(c(letters[1:3], NA), 6, TRUE)),
  f_2 = factor(c(&quot;z&quot;, &quot;a&quot;, &quot;x&quot;, &quot;c&quot;, &quot;x&quot;, &quot;x&quot;), ordered=TRUE),
  c_1 = sample(c(letters[1:3], NA), 6, TRUE),
  d_1 = as.Date(c(1:3,NA,4:5), origin=&quot;2013-09-01&quot;),
  d_2 = as.Date(6:1, origin=&quot;2012-01-01&quot;))
## add a couple of list cols
DT[, l_1 := DT[, list(c=list(rep(i_1, sample(5,1)))), by = i_1]$c]
DT[, l_2 := DT[, list(c=list(rep(c_1, sample(5,1)))), by = i_1]$c]

## original DT syntax is quite repetitive.
melt(DT, measure=patterns(
  i=&quot;^i&quot;,
  f=&quot;^f&quot;,
  d=&quot;^d&quot;,
  l=&quot;^l&quot;
))
#&gt;      c_1 variable  i    f          d              l
#&gt;  1:    a        1  1    a 2013-09-02        1,1,1,1
#&gt;  2:    a        1  2    a 2013-09-03            2,2
#&gt;  3: &lt;NA&gt;        1  3 &lt;NA&gt; 2013-09-04              3
#&gt;  4:    b        1  4    a       &lt;NA&gt;          4,4,4
#&gt;  5:    b        1  5    c 2013-09-05              5
#&gt;  6: &lt;NA&gt;        1 NA    c 2013-09-06             NA
#&gt;  7:    a        2 NA    z 2012-01-07        a,a,a,a
#&gt;  8:    a        2  6    a 2012-01-06      a,a,a,a,a
#&gt;  9: &lt;NA&gt;        2  7    x 2012-01-05             NA
#&gt; 10:    b        2  8    c 2012-01-04          b,b,b
#&gt; 11:    b        2  9    x 2012-01-03        b,b,b,b
#&gt; 12: &lt;NA&gt;        2 10    x 2012-01-02 NA,NA,NA,NA,NA

## nc syntax uses a single regex rather than four.
nc::capture_melt_multiple(
  DT,
  column=&quot;^[^c]&quot;,
  &quot;_&quot;,
  number=&quot;[12]&quot;)
#&gt;      c_1 number          d    f  i              l
#&gt;  1:    a      1 2013-09-02    a  1        1,1,1,1
#&gt;  2:    a      1 2013-09-03    a  2            2,2
#&gt;  3: &lt;NA&gt;      1 2013-09-04 &lt;NA&gt;  3              3
#&gt;  4:    b      1       &lt;NA&gt;    a  4          4,4,4
#&gt;  5:    b      1 2013-09-05    c  5              5
#&gt;  6: &lt;NA&gt;      1 2013-09-06    c NA             NA
#&gt;  7:    a      2 2012-01-07    z NA        a,a,a,a
#&gt;  8:    a      2 2012-01-06    a  6      a,a,a,a,a
#&gt;  9: &lt;NA&gt;      2 2012-01-05    x  7             NA
#&gt; 10:    b      2 2012-01-04    c  8          b,b,b
#&gt; 11:    b      2 2012-01-03    x  9        b,b,b,b
#&gt; 12: &lt;NA&gt;      2 2012-01-02    x 10 NA,NA,NA,NA,NA

## id.vars can be specified using original DT syntax.
melt(DT, id=1:2, measure=patterns(
  f=&quot;^f&quot;,
  l=&quot;^l&quot;
))
#&gt;     i_1 i_2 variable    f              l
#&gt;  1:   1  NA        1    a        1,1,1,1
#&gt;  2:   2   6        1    a            2,2
#&gt;  3:   3   7        1 &lt;NA&gt;              3
#&gt;  4:   4   8        1    a          4,4,4
#&gt;  5:   5   9        1    c              5
#&gt;  6:  NA  10        1    c             NA
#&gt;  7:   1  NA        2    z        a,a,a,a
#&gt;  8:   2   6        2    a      a,a,a,a,a
#&gt;  9:   3   7        2    x             NA
#&gt; 10:   4   8        2    c          b,b,b
#&gt; 11:   5   9        2    x        b,b,b,b
#&gt; 12:  NA  10        2    x NA,NA,NA,NA,NA

nc::capture_melt_multiple(
  DT,
  column=&quot;^[fl]&quot;,
  &quot;_&quot;,
  number=&quot;[12]&quot;)
#&gt;     i_1 i_2  c_1        d_1        d_2 number    f              l
#&gt;  1:   1  NA    a 2013-09-02 2012-01-07      1    a        1,1,1,1
#&gt;  2:   2   6    a 2013-09-03 2012-01-06      1    a            2,2
#&gt;  3:   3   7 &lt;NA&gt; 2013-09-04 2012-01-05      1 &lt;NA&gt;              3
#&gt;  4:   4   8    b       &lt;NA&gt; 2012-01-04      1    a          4,4,4
#&gt;  5:   5   9    b 2013-09-05 2012-01-03      1    c              5
#&gt;  6:  NA  10 &lt;NA&gt; 2013-09-06 2012-01-02      1    c             NA
#&gt;  7:   1  NA    a 2013-09-02 2012-01-07      2    z        a,a,a,a
#&gt;  8:   2   6    a 2013-09-03 2012-01-06      2    a      a,a,a,a,a
#&gt;  9:   3   7 &lt;NA&gt; 2013-09-04 2012-01-05      2    x             NA
#&gt; 10:   4   8    b       &lt;NA&gt; 2012-01-04      2    c          b,b,b
#&gt; 11:   5   9    b 2013-09-05 2012-01-03      2    x        b,b,b,b
#&gt; 12:  NA  10 &lt;NA&gt; 2013-09-06 2012-01-02      2    x NA,NA,NA,NA,NA

## reshape does not support list columns.
reshape(
  DT,
  varying=grep(&quot;^[fid]&quot;, names(DT)),
  sep=&quot;_&quot;,
  direction=&quot;long&quot;,
  timevar=&quot;number&quot;)
#&gt;      c_1     l_1            l_2 number  i    f          d id
#&gt;  1:    a 1,1,1,1        a,a,a,a      1  1    a 2013-09-02  1
#&gt;  2:    a     2,2      a,a,a,a,a      1  2    a 2013-09-03  2
#&gt;  3: &lt;NA&gt;       3             NA      1  3 &lt;NA&gt; 2013-09-04  3
#&gt;  4:    b   4,4,4          b,b,b      1  4    a       &lt;NA&gt;  4
#&gt;  5:    b       5        b,b,b,b      1  5    c 2013-09-05  5
#&gt;  6: &lt;NA&gt;      NA NA,NA,NA,NA,NA      1 NA    c 2013-09-06  6
#&gt;  7:    a 1,1,1,1        a,a,a,a      2 NA    z 2012-01-07  1
#&gt;  8:    a     2,2      a,a,a,a,a      2  6    a 2012-01-06  2
#&gt;  9: &lt;NA&gt;       3             NA      2  7    x 2012-01-05  3
#&gt; 10:    b   4,4,4          b,b,b      2  8    c 2012-01-04  4
#&gt; 11:    b       5        b,b,b,b      2  9    x 2012-01-03  5
#&gt; 12: &lt;NA&gt;      NA NA,NA,NA,NA,NA      2 10    x 2012-01-02  6

## tidyr does, but errors for combining ordered and un-ordered factors.
if(requireNamespace(&quot;tidyr&quot;)){
  tidyr::pivot_longer(
    DT, grep(&quot;[cf]&quot;, names(DT), invert=TRUE),
    names_pattern=&quot;(.)_(.)&quot;,
    names_to=c(&quot;.value&quot;, &quot;number&quot;))
}
#&gt; # A tibble: 12 x 7
#&gt;    f_1   f_2   c_1   number     i d          l        
#&gt;    &lt;fct&gt; &lt;ord&gt; &lt;chr&gt; &lt;chr&gt;  &lt;int&gt; &lt;date&gt;     &lt;list&gt;   
#&gt;  1 a     z     a     1          1 2013-09-02 &lt;int [4]&gt;
#&gt;  2 a     z     a     2         NA 2012-01-07 &lt;chr [4]&gt;
#&gt;  3 a     a     a     1          2 2013-09-03 &lt;int [2]&gt;
#&gt;  4 a     a     a     2          6 2012-01-06 &lt;chr [5]&gt;
#&gt;  5 &lt;NA&gt;  x     &lt;NA&gt;  1          3 2013-09-04 &lt;int [1]&gt;
#&gt;  6 &lt;NA&gt;  x     &lt;NA&gt;  2          7 2012-01-05 &lt;chr [1]&gt;
#&gt;  7 a     c     b     1          4 NA         &lt;int [3]&gt;
#&gt;  8 a     c     b     2          8 2012-01-04 &lt;chr [3]&gt;
#&gt;  9 c     x     b     1          5 2013-09-05 &lt;int [1]&gt;
#&gt; 10 c     x     b     2          9 2012-01-03 &lt;chr [4]&gt;
#&gt; 11 c     x     &lt;NA&gt;  1         NA 2013-09-06 &lt;int [1]&gt;
#&gt; 12 c     x     &lt;NA&gt;  2         10 2012-01-02 &lt;chr [5]&gt;
</code></pre>

<h2>family data</h2>

<pre><code class="r">
## Example 3, three children, one family per row, from data.table
## vignette.
family.dt &lt;- fread(text=&quot;
family_id age_mother dob_child1 dob_child2 dob_child3 gender_child1 gender_child2 gender_child3
1         30 1998-11-26 2000-01-29         NA             1             2            NA
2         27 1996-06-22         NA         NA             2            NA            NA
3         26 2002-07-11 2004-04-05 2007-09-02             2             2             1
4         32 2004-10-10 2009-08-27 2012-07-21             1             1             1
5         29 2000-12-05 2005-02-28         NA             2             1            NA&quot;)
(children.melt &lt;- melt(family.dt, measure = patterns(
  dob=&quot;^dob&quot;, gender=&quot;^gender&quot;
), na.rm=TRUE, variable.factor=FALSE))
#&gt;     family_id age_mother variable        dob gender
#&gt;  1:         1         30        1 1998-11-26      1
#&gt;  2:         2         27        1 1996-06-22      2
#&gt;  3:         3         26        1 2002-07-11      2
#&gt;  4:         4         32        1 2004-10-10      1
#&gt;  5:         5         29        1 2000-12-05      2
#&gt;  6:         1         30        2 2000-01-29      2
#&gt;  7:         3         26        2 2004-04-05      2
#&gt;  8:         4         32        2 2009-08-27      1
#&gt;  9:         5         29        2 2005-02-28      1
#&gt; 10:         3         26        3 2007-09-02      1
#&gt; 11:         4         32        3 2012-07-21      1

## nc::field can be used to define group name and pattern at the
## same time, to avoid repetitive code.
(children.nc &lt;- nc::capture_melt_multiple(
  family.dt,
  column=&quot;[^_]+&quot;,
  &quot;_&quot;,
  nc::field(&quot;child&quot;, &quot;&quot;, &quot;[1-3]&quot;),
  na.rm=TRUE))
#&gt;     family_id age_mother child        dob gender
#&gt;  1:         1         30     1 1998-11-26      1
#&gt;  2:         2         27     1 1996-06-22      2
#&gt;  3:         3         26     1 2002-07-11      2
#&gt;  4:         4         32     1 2004-10-10      1
#&gt;  5:         5         29     1 2000-12-05      2
#&gt;  6:         1         30     2 2000-01-29      2
#&gt;  7:         3         26     2 2004-04-05      2
#&gt;  8:         4         32     2 2009-08-27      1
#&gt;  9:         5         29     2 2005-02-28      1
#&gt; 10:         3         26     3 2007-09-02      1
#&gt; 11:         4         32     3 2012-07-21      1

## reshape works too.
stats::reshape(
  family.dt,
  varying=grep(&quot;child&quot;, names(family.dt)),
  direction=&quot;long&quot;,
  sep=&quot;_&quot;,
  timevar=&quot;child.str&quot;)
#&gt;     family_id age_mother child.str        dob gender id
#&gt;  1:         1         30    child1 1998-11-26      1  1
#&gt;  2:         2         27    child1 1996-06-22      2  2
#&gt;  3:         3         26    child1 2002-07-11      2  3
#&gt;  4:         4         32    child1 2004-10-10      1  4
#&gt;  5:         5         29    child1 2000-12-05      2  5
#&gt;  6:         1         30    child2 2000-01-29      2  1
#&gt;  7:         2         27    child2       &lt;NA&gt;     NA  2
#&gt;  8:         3         26    child2 2004-04-05      2  3
#&gt;  9:         4         32    child2 2009-08-27      1  4
#&gt; 10:         5         29    child2 2005-02-28      1  5
#&gt; 11:         1         30    child3       &lt;NA&gt;     NA  1
#&gt; 12:         2         27    child3       &lt;NA&gt;     NA  2
#&gt; 13:         3         26    child3 2007-09-02      1  3
#&gt; 14:         4         32    child3 2012-07-21      1  4
#&gt; 15:         5         29    child3       &lt;NA&gt;     NA  5
</code></pre>

<h2>histogram of iris</h2>

<pre><code class="r">
## Comparison with base R. 1. mfrow means parts on rows, mfcol means
## parts on columns. 2. same number of lines of code. 3. nc/ggplot2
## code has more names and fewer numbers.
imat &lt;- as.matrix(iris[, 1:4])
ylim &lt;- range(table(imat))
xlim &lt;- range(imat)
par(mfcol=c(2,2), mar=c(2,2,1,1))
for(col.i in 1:ncol(imat)){
  hist(
    imat[, col.i],
    breaks=seq(xlim[1], xlim[2], by=0.1),
    ylim=ylim,
    main=colnames(imat)[col.i])
}
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-19"/></p>

<h3>single output column simple type conversion</h3>

<p>All four packages below can convert the input reshape column name to a
numeric output capture column.</p>

<pre><code class="r">
pen.peaks.wide &lt;- data.table::data.table(
  data.set=c(&quot;foo&quot;, &quot;bar&quot;),
  &quot;10.1&quot;=c(5L, 10L),
  &quot;0.3&quot;=c(26L, 39L))
pen.peaks.gather &lt;- if(requireNamespace(&quot;tidyr&quot;))tidyr::gather(
  pen.peaks.wide,
  &quot;penalty&quot;,
  &quot;peaks&quot;,
  -1,
  convert=TRUE)
str(pen.peaks.gather)
#&gt; &#39;data.frame&#39;:    4 obs. of  3 variables:
#&gt;  $ data.set: chr  &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot;
#&gt;  $ penalty : num  10.1 10.1 0.3 0.3
#&gt;  $ peaks   : int  5 10 26 39

pen.peaks.nc &lt;- nc::capture_melt_single(
  pen.peaks.wide,
  penalty=&quot;^[0-9.]+&quot;, as.numeric,
  value.name=&quot;peaks&quot;)
str(pen.peaks.nc)
#&gt; Classes &#39;data.table&#39; and &#39;data.frame&#39;:   4 obs. of  3 variables:
#&gt;  $ data.set: chr  &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot;
#&gt;  $ penalty : num  10.1 10.1 0.3 0.3
#&gt;  $ peaks   : int  5 10 26 39
#&gt;  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;

pen.peaks.pivot &lt;- if(requireNamespace(&quot;tidyr&quot;))try(tidyr::pivot_longer(
  pen.peaks.wide,
  -1,
  names_to=&quot;penalty&quot;,
  names_transform=list(penalty=as.numeric),
  values_to=&quot;peaks&quot;))
str(pen.peaks.pivot)
#&gt; tibble [4 Ã— 3] (S3: tbl_df/tbl/data.frame)
#&gt;  $ data.set: chr [1:4] &quot;foo&quot; &quot;foo&quot; &quot;bar&quot; &quot;bar&quot;
#&gt;  $ penalty : num [1:4] 10.1 0.3 10.1 0.3
#&gt;  $ peaks   : int [1:4] 5 26 10 39

varying &lt;- 2:3
pen.peaks.reshape.times &lt;- stats::reshape(
  pen.peaks.wide,
  direction=&quot;long&quot;,
  varying=varying,
  times=as.numeric(names(pen.peaks.wide)[varying]),
  v.names=&quot;peaks&quot;,
  timevar=&quot;penalty&quot;)
str(pen.peaks.reshape.times)
#&gt; Classes &#39;data.table&#39; and &#39;data.frame&#39;:   4 obs. of  4 variables:
#&gt;  $ data.set: chr  &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot;
#&gt;  $ penalty : num  10.1 10.1 0.3 0.3
#&gt;  $ peaks   : int  5 10 26 39
#&gt;  $ id      : int  1 2 1 2
#&gt;  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; 
#&gt;  - attr(*, &quot;reshapeLong&quot;)=List of 4
#&gt;   ..$ varying:List of 1
#&gt;   .. ..$ peaks: chr [1:2] &quot;10.1&quot; &quot;0.3&quot;
#&gt;   .. ..- attr(*, &quot;v.names&quot;)= chr &quot;peaks&quot;
#&gt;   .. ..- attr(*, &quot;times&quot;)= num [1:2] 10.1 0.3
#&gt;   ..$ v.names: chr &quot;peaks&quot;
#&gt;   ..$ idvar  : chr &quot;id&quot;
#&gt;   ..$ timevar: chr &quot;penalty&quot;

pen.peaks.renamed &lt;- pen.peaks.wide
names(pen.peaks.renamed) &lt;- paste0(ifelse(
  grepl(&quot;^[0-9]&quot;, names(pen.peaks.wide)),
  &quot;peaks_&quot;, &quot;&quot;),
  names(pen.peaks.wide))
pen.peaks.reshape.sep &lt;- stats::reshape(
  pen.peaks.renamed,
  direction=&quot;long&quot;,
  varying=varying,
  sep=&quot;_&quot;,
  timevar=&quot;penalty&quot;)
str(pen.peaks.reshape.sep)
#&gt; Classes &#39;data.table&#39; and &#39;data.frame&#39;:   4 obs. of  4 variables:
#&gt;  $ data.set: chr  &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot;
#&gt;  $ penalty : num  10.1 10.1 0.3 0.3
#&gt;  $ peaks   : int  5 10 26 39
#&gt;  $ id      : int  1 2 1 2
#&gt;  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; 
#&gt;  - attr(*, &quot;reshapeLong&quot;)=List of 4
#&gt;   ..$ varying:List of 1
#&gt;   .. ..$ peaks: chr [1:2] &quot;peaks_10.1&quot; &quot;peaks_0.3&quot;
#&gt;   .. ..- attr(*, &quot;v.names&quot;)= chr &quot;peaks&quot;
#&gt;   .. ..- attr(*, &quot;times&quot;)= num [1:2] 10.1 0.3
#&gt;   ..$ v.names: chr &quot;peaks&quot;
#&gt;   ..$ idvar  : chr &quot;id&quot;
#&gt;   ..$ timevar: chr &quot;penalty&quot;
</code></pre>

</body>

</html>
